import random
import math
import statistics
from typing import List
import numpy as np

DIRECTIONS = [-10, 10, -1, 1]
START = 50

def room_count(floor: int, xl: bool, curse: bool, void: bool = False) -> int:
    """
    If the floor is not XL or Added in Afterbirth † The Void:
        NumberOfRooms = 3.33 × FloorDepth + 5-6 (maximum of 20)
    If the floor is an XL floor:
        NumberOfRooms = 1.8 × (3.33 × FloorDepth + 5-6) (maximum of 45)
    If the floor is The Void:
        NumberOfRooms = 50-59
    2-3 more rooms are added if playing on Hard Mode
    4 more rooms are added if the floor has Curse of the Lost.

    Parameters:
        floor (int): The floor number to generate the room count for
        xl (bool): Is there Curse of the Labarynth
        curse (bool): Is there Curse of the lost
        void (bool): Is it the void
    Returns:
        rooms (int): The number of rooms for that floor
    """
    rooms = 3.33 * floor + random.randint(5, 6) + random.randint(2, 3)
    if void:
        return random.randint(50, 59)
    if not xl:
        if rooms >= 20:
            rooms = 20
        if not curse:
            return math.floor(rooms)
        return math.floor(rooms) + 4
    if xl:
        rooms = rooms * 1.8
        if rooms >= 45:
            return 45
        return math.floor(rooms)


def get_coords(direction: int) -> np.array:
    """Converts cell direction into coordinates.
    
    Parameters:
        direction (int): The direction the neighbour is in
    Returns:
        directioncs (np.array): The direction in the form of coordinates
    """
    if direction == -10:
        return np.array([[0, -1]])
    if direction == 10:
        return np.array([[0, 1]])
    if direction == -1:
        return np.array([[-1, 0]])
    if direction == 1:
        return np.array([[1, 0]])


def enough_neighbours(cell: int, rooms: List[int]) -> bool:
    """Checks whether the neighbour already has more than one neighbour attached.
    
    Parameters:
        cell (int): The cell to check the neighbours of
        rooms (List): The list of current rooms in the level
    Returns:
        enough_neighbours (bool): Whether there are enough neighbours
    """
    count = 0
    for d in DIRECTIONS:
        if cell + d in rooms:
            count += 1
    if count > 1:
        return True
    return False


def levelgen(nrooms) -> tuple:
    """Generates a list of rooms for the level based on the description found
    here: https://www.boristhebrave.com/2020/09/12/dungeon-generation-in-binding-of-isaac/.
    Also calculates a set of coordinates for plotting

    Returns:
        rooms (List): A list of rooms for the level
        coords (np.array): A numpy array of coordinates
    """
    current = START
    rooms = [current]
    coords = np.array([[5, 5]])
    while len(rooms) < nrooms:
        for i, room in enumerate(rooms):
            if len(rooms) > nrooms:
                break
            for d in DIRECTIONS:
                if len(rooms) > nrooms:
                    break
                neighbour = room + d
                if neighbour in rooms:
                    continue
                if enough_neighbours(neighbour, rooms):
                    continue
                if random.choice([0,1]) == 0:
                    continue
                else:
                    dcoords = get_coords(d)
                    coords = np.append(coords, coords[i] + dcoords, axis=0)
                    rooms.append(neighbour)
    return rooms, coords


def calc_route_to_boss(rooms: List[int]) -> List[int]:
    """Calculates the route from the boss room to the start room.

    Parameters:
        rooms (List): The list of rooms from the levelgen function
    Returns:
        route (List): The route from boss room to start room
    """
    rooms.reverse()
    ds = DIRECTIONS.copy()
    solved = False
    i = 0
    while not solved:
        random.shuffle(ds)
        route = [rooms[0]]
        for room in route:
            for d in ds:
                if room + d in rooms and room + d not in route:
                    route.append(room + d)
                    if route[-1] == rooms[-1]:
                        return route
                    else:
                        break
        i += 1
        if i % 100 == 0:
            break


def calc_coords_to_boss(rooms: List[int], route: List[int], coords: np.array) -> np.array:
    """Uses the indexes of the values of the route from the rooms to select the coordinates
    
    Parameters:
        rooms (List): The list of rooms generated by levengen
        route (List): The route calculated by calc_route_to_boss
        coords (np.array): The Numpy array of coordinates used for visualisation
    Returns:
        routecs (np.array): The Numpy array of coordinates for the route
    """
    indices = [rooms.index(cell) for cell in route]
    routecs = []
    for index in indices:
        routecs.append(coords[index])
    return np.array(routecs)


def run_mcs(nrooms) -> float:
    """Runs a Monte Carlo Simulation to calculate the average
    number of rooms the player must pass through on the shortest
    trip to the boss.

    Parameters:
        nrooms (int): The number of rooms based on the room_count function
    Returns:
        average (float): The average number of rooms needed to traverse the level
    """
    res = []
    for _ in range(10000):
        rooms, _ = levelgen(nrooms)
        route = calc_route_to_boss(rooms)
        if route:
            res.append(len(route))
    return statistics.mean(res)


if __name__ == "__main__":
    nrooms = room_count(1, False, False)
    print(f"NUMBER OF ROOMS ON THE LEVEL: {nrooms}")
    print(f"AVERAGE NUMBER OF ROOMS TO BOSS: {run_mcs(nrooms)}")
